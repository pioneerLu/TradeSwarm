# trading_strategy 的理解

## 1. 核心定位

trading_strategy 是系统在盘前阶段生成的结构化交易策略，是 LLM 分析结果到算法执行之间的桥梁。

## 2. 设计理念

采用"慢思考（LLM）+ 快执行（Algo）"模式：

- **盘前**：LLM 生成结构化策略（JSON）
- **盘中**：纯算法执行，不调用 LLM
- **盘后**：复盘并更新策略历史

## 3. 数据结构

参考 ExecutionPlan 的结构，trading_strategy 应包含：

```json
{
  "target_symbol": "000001.SZ",
  "direction": "long",  // long, short, hold
  "strategy_id": "breakout_ma_v1",  // 预定义的策略模板ID
  "parameters": {
    "trigger_condition": "price > ma_20",  // 触发条件
    "buy_limit_price": 12.50,  // 最高买入价
    "stop_loss_price": 11.80,  // 硬止损
    "take_profit_price": 13.50,  // 止盈位
    "position_size_pct": 0.2,  // 仓位占比
    "max_holding_time_mins": 240  // 最大持仓时间
  },
  "validity_factors": [
    {"factor": "rsi_14", "condition": "< 70"},
    {"factor": "volume_ratio", "condition": "> 1.2"}
  ],
  "expiration": "15:00:00"  // 策略有效期
}
```

## 4. 生命周期

### 生成阶段（盘前 8:00-9:30）

- Research/Risk Manager 输出 → 策略生成节点
- 整合为结构化 JSON
- 保存到 memory.db 的 trading_strategies 表

### 执行阶段（盘中 9:30-15:00）

- 策略执行节点读取策略
- 算法监控触发条件
- 执行买入/卖出，记录执行日志

### 复盘阶段（盘后 15:00+）

- 统计当日表现
- 更新策略历史
- 评估策略有效性

## 5. 与 AgentState 的关系

文档提到需要在 AgentState 中添加：

- `trading_session`：当前交易时段（pre_open / market_open / intraday / post_close）
- `trading_strategy`：当前执行的策略（ExecutionPlan 格式）
- `strategy_status`：策略状态（pending / active / completed / stopped）

## 6. 关键特点

- **结构化**：JSON 格式，便于算法解析
- **可执行**：包含明确的触发条件、止损止盈等参数
- **可持久化**：保存到数据库，作为历史经验
- **可回溯**：记录执行结果，用于复盘和优化

## 7. 与现有设计的关系

- **与 ExecutionPlan**：trading_strategy 可能就是 ExecutionPlan 的持久化版本
- **与 trader_investment_plan**：trader_investment_plan 可能是文本摘要，而 trading_strategy 是结构化可执行版本
- **与策略模板**：strategy_id 指向预定义模板（如 "breakout_ma_v1"），LLM 填充参数

## 总结

trading_strategy 是 LLM 决策的结构化、可执行、可持久化的表示，连接 LLM 的"慢思考"与算法的"快执行"，是混合架构的核心组件。

---

# strategy_status 的理解

## 1. 核心定位

strategy_status 是策略状态机字段，用于跟踪策略从生成到执行到结束的完整生命周期。

## 2. 可能的状态值

根据文档中的策略生命周期，strategy_status 可能包含以下状态：

```python
Literal["pending", "active", "completed", "stopped", "expired", "cancelled"]
```

## 3. 状态转换流程

```
pending (待执行)
  ↓ [开盘时激活]
active (执行中)
  ↓ [触发条件满足/止损止盈/到期]
completed (已完成) / stopped (已停止) / expired (已过期)
```

## 4. 各状态的含义

### pending（待执行）

- 盘前生成策略后
- 策略已保存到数据库，等待开盘执行
- 对应 `trading_session = "pre_open"`

### active（执行中）

- 开盘后策略被激活
- 策略执行节点正在监控和执行
- 对应 `trading_session = "intraday"`
- 算法持续检查触发条件、止损止盈

### completed（已完成）

- 策略正常执行完毕
- 可能原因：触发条件满足并完成交易、达到止盈、达到最大持仓时间
- 对应 `trading_session = "post_close"`

### stopped（已停止）

- 策略被提前终止
- 可能原因：触发止损、风控规则触发、手动停止
- 需要记录停止原因

### expired（已过期）

- 策略超过有效期（expiration 字段）
- 未触发执行条件，自动失效

### cancelled（已取消）

- 盘后复盘判定策略无效，主动取消
- 或盘前重新生成新策略，旧策略被取消

## 5. 与 trading_session 的关系

strategy_status 和 trading_session 配合使用：

| trading_session | strategy_status 可能值 | 说明 |
|----------------|----------------------|------|
| pre_open | pending | 策略已生成，等待开盘 |
| market_open | pending → active | 开盘时激活策略 |
| intraday | active | 策略执行中 |
| post_close | completed / stopped / expired | 策略结束，等待复盘 |

## 6. 实际应用场景

### 策略执行节点判断

```python
if strategy_status == "active":
    # 执行策略监控逻辑
    check_trigger_conditions()
elif strategy_status == "pending":
    # 等待激活
    wait_for_market_open()
```

### 盘后复盘判断

```python
if strategy_status == "completed":
    # 分析策略执行效果
    analyze_performance()
elif strategy_status == "stopped":
    # 分析停止原因
    analyze_stop_reason()
```

### 数据库查询

```sql
-- 查询当前活跃策略
SELECT * FROM trading_strategies
WHERE strategy_status = 'active';

-- 查询已完成策略用于复盘
SELECT * FROM trading_strategies
WHERE strategy_status IN ('completed', 'stopped')
AND trade_date = '2025-01-15';
```

## 7. 状态更新时机

- **pending → active**：开盘时（9:30），策略执行节点激活
- **active → completed**：触发条件满足并完成交易
- **active → stopped**：触发止损或风控规则
- **active → expired**：超过 expiration 时间
- **任何状态 → cancelled**：盘后复盘判定无效或生成新策略

## 8. 设计目的

- **状态追踪**：明确策略当前阶段
- **执行控制**：只有 active 状态的策略才会被执行